// Generated by CoffeeScript 1.10.0
(function() {
  var MySQLSchemaGenerator, SchemaGenerator, _, unitConverter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SchemaGenerator = require('../SchemaGenerator');

  unitConverter = require('unit-converter');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLSchemaGenerator = (function(superClass) {
    extend(MySQLSchemaGenerator, superClass);

    function MySQLSchemaGenerator(options1) {
      this.options = options1 != null ? options1 : {};
      this.options.identifierType = this.options.identifierType || 'int';
    }

    MySQLSchemaGenerator.prototype.generateSchema = function(definition) {
      var entity, i, j, len, len1, ref, ref1, ref2, relation, sqls;
      sqls = [];
      ref = definition.entities;
      for (i = 0, len = ref.length; i < len; i++) {
        entity = ref[i];
        sqls.push(this._tableDefinition(entity));
        ref1 = entity.relations;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          relation = ref1[j];
          if (relation.toMany && ((ref2 = relation.inverse) != null ? ref2.toMany : void 0) && relation.primary) {
            sqls.push(this._manyToManyRelationDefinition(relation, entity));
          }
        }
      }
      if (sqls.length === 0) {
        return null;
      } else {
        return sqls.join(";\n") + ';';
      }
    };

    MySQLSchemaGenerator.prototype._tableDefinition = function(entity) {
      var column, i, index, j, k, len, len1, len2, ref, ref1, ref2, relation, sql, str, tableParts;
      tableParts = [this._identifierColumn('id') + ' AUTO_INCREMENT', 'PRIMARY KEY (`id`)'];
      ref = entity.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        tableParts.push(this._columnDefinitionForAttribute(column));
      }
      ref1 = entity.relations;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        relation = ref1[j];
        if (!relation.toMany) {
          tableParts.push(this._identifierColumn(relation.name + '_id', false));
          tableParts.push('KEY `' + relation.name + '_id` (`' + relation.name + '_id`)');
        }
      }
      if (entity.indexes) {
        ref2 = entity.indexes;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          index = ref2[k];
          str = '';
          if (index.unique) {
            str = 'UNIQUE ';
          }
          str += 'KEY `' + index.name + '` ';
          str += '(`' + index.columns.join('`,`') + '`)';
          tableParts.push(str);
        }
      }
      sql = "CREATE TABLE IF NOT EXISTS `" + this._tableNameForEntity(entity) + "` (";
      sql += tableParts.join(",");
      sql += ") ENGINE=InnoDB DEFAULT CHARSET=utf8";
      return sql;
    };

    MySQLSchemaGenerator.prototype._relationTableName = function(relation, entity) {
      var entityTableName;
      entityTableName = this._tableNameForEntity(entity);
      return entityTableName + '_' + relation.name;
    };

    MySQLSchemaGenerator.prototype._manyToManyRelationDefinition = function(relation, entity) {
      var entityTableName, relationTableName, sql;
      entityTableName = this._tableNameForEntity(entity);
      relationTableName = _.singularize(relation.name);
      sql = 'CREATE TABLE IF NOT EXISTS `' + this._relationTableName(relation, entity) + '` (' + this._identifierColumn(entityTableName + '_id') + ',' + this._identifierColumn(relationTableName + '_id') + ', PRIMARY KEY (`' + entityTableName + '_id`,`' + relationTableName + '_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8';
      return sql;
    };

    MySQLSchemaGenerator.prototype.generateSchemaMigration = function(definitions, versionFrom, versionTo) {
      var maxVersion, sqls, version;
      sqls = [];
      version = versionFrom;
      maxVersion = version;
      while (true) {
        version = this._generateSchemaMigration(definitions, version, sqls);
        if (version) {
          maxVersion = version;
        }
        if (!version || version + '' === versionTo + '') {
          break;
        }
      }
      if (sqls.length === 0) {
        return null;
      } else {
        return sqls.join(";\n") + ';';
      }
    };

    MySQLSchemaGenerator.prototype._generateSchemaMigration = function(definitions, version, sqls) {
      var alterPrefix, column, columnName, entity, i, j, k, key, len, len1, len2, migration, migrationKey, newVersion, oldSchema, ref, ref1, ref2, ref3, ref4, rel, relation, s, schema;
      migration = null;
      schema = null;
      migrationKey = null;
      newVersion = null;
      for (key in definitions) {
        s = definitions[key];
        if (key.indexOf(version + '->') === 0) {
          migrationKey = key;
          migration = s;
          newVersion = key.split('->')[1];
          schema = definitions[newVersion];
          oldSchema = definitions[version];
          break;
        }
      }
      if (!migration) {
        throw new Error('migration not found for version ' + version);
      }
      if (!schema) {
        throw new Error('destination schema not found for migration ' + migrationKey);
      }
      ref = migration.entities;
      for (i = 0, len = ref.length; i < len; i++) {
        entity = ref[i];
        if (entity.type === 'add') {
          sqls.push(this._tableDefinition(schema.getEntity(entity.name)));
        } else if (entity.type === 'remove') {
          sqls.push('DROP TABLE IF EXISTS `' + this._tableNameForEntity(entity) + '`');
        } else {
          alterPrefix = 'ALTER TABLE `' + this._tableNameForEntity(entity) + '`';
          ref1 = entity.columns;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            column = ref1[j];
            if (column.type === 'remove') {
              sqls.push(alterPrefix + ' DROP COLUMN `' + column.name + '`');
            } else if (column.type === 'add') {
              sqls.push(alterPrefix + ' ADD COLUMN ' + this._columnDefinitionForAttribute(schema.getColumn(entity.name, column.name)));
            } else if (column.type === 'change') {
              sqls.push(alterPrefix + ' CHANGE `' + column.name + '` ' + this._columnDefinitionForAttribute(schema.getColumn(entity.name, column.target)));
            }
          }
          ref2 = entity.relations;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            relation = ref2[k];
            switch (relation.type) {
              case 'add':
                rel = schema.getRelation(entity.name, relation.name);
                if (!rel) {
                  throw new Error('relation ' + entity.name + '=>' + relation.name + ' not found');
                }
                if (!rel.toMany) {
                  columnName = relation.name + '_id';
                  sqls.push(alterPrefix + ' ADD COLUMN ' + this._identifierColumn(columnName, false));
                  sqls.push(alterPrefix + ' ADD INDEX (`' + columnName + '`)');
                } else if (rel.toMany && ((ref3 = rel.inverse) != null ? ref3.toMany : void 0)) {
                  if (relation.type === 'add') {
                    sqls.push(this._manyToManyRelationDefinition(rel, entity));
                  }
                }
                break;
              case 'remove':
                rel = oldSchema.getRelation(entity.name, relation.name);
                if (!rel) {
                  throw new Error('relation ' + entity.name + '=>' + relation.name + ' not found');
                }
                if (!rel.toMany) {
                  columnName = relation.name + '_id';
                  sqls.push(alterPrefix + ' DROP COLUMN ' + this._identifierColumn(columnName, false));
                } else if (rel.toMany && ((ref4 = rel.inverse) != null ? ref4.toMany : void 0)) {
                  sqls.push('DROP TABLE IF EXISTS `' + this._relationTableName(rel, entity) + '`');
                }
                break;
            }
          }
        }
      }
      return newVersion;
    };

    MySQLSchemaGenerator.prototype._identifierColumn = function(name, notNull) {
      var sql;
      if (notNull == null) {
        notNull = true;
      }
      sql = '`' + name + '` ' + this._sqlTypeForColumnType(this.options.identifierType);
      if (notNull) {
        sql += ' NOT NULL';
      } else {
        sql += ' NULL DEFAULT NULL';
      }
      return sql;
    };

    MySQLSchemaGenerator.prototype._columnDefinitionForAttribute = function(column) {
      var defaultValue, definition, type;
      type = this._sqlTypeForColumnType(column.type, column);
      defaultValue = 'DEFAULT NULL';
      if (column["default"]) {
        defaultValue = "DEFAULT '" + column["default"] + "'";
      }
      definition = '`' + column.name + '` ' + type;
      if (column.notNull) {
        definition += ' NOT NULL';
      } else {
        definition += ' NULL';
      }
      definition += ' ' + defaultValue;
      if (column.unique) {
        definition += ', UNIQUE(`' + column.name + '`)';
      }
      return definition;
    };

    MySQLSchemaGenerator.prototype._sqlTypeForColumnType = function(columnType, options) {
      var length, type;
      if (options == null) {
        options = {};
      }
      type = null;
      if (options.length) {
        length = unitConverter(options.length + 'B').to('B');
      }
      switch (columnType) {
        case 'bool':
        case 'boolean':
          return 'tinyint(1)';
        case 'string':
        case 'email':
        case 'url':
          return 'varchar(' + (length || 255) + ')';
        case 'text':
          if (length) {
            if (length < 256) {
              return 'tinytext';
            } else if (length < 65536) {
              return 'text';
            } else if (length < 16777216) {
              return 'mediumtext';
            } else if (length < 4294967296) {
              return 'longtext';
            }
          } else {
            return 'longtext';
          }
          break;
        case 'data':
          if (length) {
            if (length < 256) {
              return 'tinyblob';
            } else if (length < 65536) {
              return 'blob';
            } else if (length < 16777216) {
              return 'mediumblob';
            } else if (length < 4294967296) {
              return 'longblob';
            }
          } else {
            return 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          return 'int(' + (length || 11) + ')';
        case 'decimal':
          return 'decimal(' + (options.digits || 20) + ',' + (options.decimals || 5) + ')';
        case 'float':
          return 'float';
        case 'double':
          return 'double';
        case 'date':
          return 'datetime';
        case 'timestamp':
          return 'timestamp';
        default:
          throw new Error('unknown column type ' + columnType);
      }
    };

    return MySQLSchemaGenerator;

  })(SchemaGenerator);

  module.exports = MySQLSchemaGenerator;

}).call(this);
