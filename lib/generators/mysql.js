// Generated by CoffeeScript 1.6.3
(function() {
  var MySQLSchemaGenerator, SchemaGenerator, async, unitParser, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SchemaGenerator = require('../SchemaGenerator');

  async = require('async');

  unitParser = require('unit-parser');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLSchemaGenerator = (function(_super) {
    __extends(MySQLSchemaGenerator, _super);

    function MySQLSchemaGenerator(options) {
      this.options = options != null ? options : {};
      this.options.identifierType = this.options.identifierType || 'int';
    }

    MySQLSchemaGenerator.prototype.generateSchema = function(definition) {
      var entity, relation, sqls, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      sqls = [];
      _ref = definition.entities;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        sqls.push(this._tableDefinition(entity));
        _ref1 = entity.relations;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          relation = _ref1[_j];
          if (relation.toMany && ((_ref2 = relation.inverse) != null ? _ref2.toMany : void 0) && relation.primary) {
            sqls.push(this._manyToManyRelationDefinition(relation, entity));
          }
        }
      }
      if (sqls.length === 0) {
        return null;
      } else {
        return sqls.join(";\n") + ';';
      }
    };

    MySQLSchemaGenerator.prototype._tableDefinition = function(entity) {
      var column, index, relation, sql, str, tableParts, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      tableParts = [this._identifierColumn('id') + ' AUTO_INCREMENT', 'PRIMARY KEY (`id`)'];
      _ref = entity.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        column = _ref[_i];
        tableParts.push(this._columnDefinitionForAttribute(column));
      }
      _ref1 = entity.relations;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        relation = _ref1[_j];
        if (!relation.toMany) {
          tableParts.push(this._identifierColumn(relation.name + '_id', false));
          tableParts.push('KEY `' + relation.name + '_id` (`' + relation.name + '_id`)');
        }
      }
      if (entity.indexes) {
        _ref2 = entity.indexes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          index = _ref2[_k];
          str = '';
          if (index.unique) {
            str = 'UNIQUE ';
          }
          str += 'KEY `' + index.name + '` ';
          str += '(`' + index.columns.join('`,`') + '`)';
          tableParts.push(str);
        }
      }
      sql = "CREATE TABLE IF NOT EXISTS `" + this._tableNameForEntity(entity) + "` (";
      sql += tableParts.join(",");
      sql += ") ENGINE=InnoDB DEFAULT CHARSET=utf8";
      return sql;
    };

    MySQLSchemaGenerator.prototype._relationTableName = function(relation, entity) {
      var entityTableName;
      entityTableName = this._tableNameForEntity(entity);
      return entityTableName + '_' + relation.name;
    };

    MySQLSchemaGenerator.prototype._manyToManyRelationDefinition = function(relation, entity) {
      var entityTableName, relationTableName, sql;
      entityTableName = this._tableNameForEntity(entity);
      relationTableName = _.singularize(relation.name);
      sql = 'CREATE TABLE IF NOT EXISTS `' + this._relationTableName(relation, entity) + '` (' + this._identifierColumn(entityTableName + '_id') + ',' + this._identifierColumn(relationTableName + '_id') + ', PRIMARY KEY (`' + entityTableName + '_id`,`' + relationTableName + '_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8';
      return sql;
    };

    MySQLSchemaGenerator.prototype.generateSchemaMigration = function(definitions, versionFrom, versionTo) {
      var maxVersion, sqls, version;
      sqls = [];
      version = versionFrom;
      maxVersion = version;
      while (true) {
        version = this._generateSchemaMigration(definitions, version, sqls);
        if (version) {
          maxVersion = version;
        }
        if (!version || version + '' === versionTo + '') {
          break;
        }
      }
      if (sqls.length === 0) {
        return null;
      } else {
        return sqls.join(";\n") + ';';
      }
    };

    MySQLSchemaGenerator.prototype._generateSchemaMigration = function(definitions, version, sqls) {
      var alterPrefix, column, columnName, entity, key, migration, migrationKey, newVersion, oldSchema, rel, relation, s, schema, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
      migration = null;
      schema = null;
      migrationKey = null;
      newVersion = null;
      for (key in definitions) {
        s = definitions[key];
        if (key.indexOf(version + '->') === 0) {
          migrationKey = key;
          migration = s;
          newVersion = key.split('->')[1];
          schema = definitions[newVersion];
          oldSchema = definitions[version];
          break;
        }
      }
      if (!migration) {
        throw new Error('migration not found for version ' + version);
      }
      if (!schema) {
        throw new Error('destination schema not found for migration ' + migrationKey);
      }
      _ref = migration.entities;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        if (entity.type === 'add') {
          sqls.push(this._tableDefinition(schema.getEntity(entity.name)));
        } else if (entity.type === 'remove') {
          sqls.push('DROP TABLE IF EXISTS `' + this._tableNameForEntity(entity) + '`');
        } else {
          alterPrefix = 'ALTER TABLE `' + this._tableNameForEntity(entity) + '`';
          _ref1 = entity.columns;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            column = _ref1[_j];
            if (column.type === 'remove') {
              sqls.push(alterPrefix + ' DROP COLUMN `' + column.name + '`');
            } else if (column.type === 'add') {
              sqls.push(alterPrefix + ' ADD COLUMN ' + this._columnDefinitionForAttribute(schema.getColumn(entity.name, column.name)));
            } else if (column.type === 'change') {
              sqls.push(alterPrefix + ' CHANGE `' + column.name + '` ' + this._columnDefinitionForAttribute(schema.getColumn(entity.name, column.target)));
            }
          }
          _ref2 = entity.relations;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            relation = _ref2[_k];
            switch (relation.type) {
              case 'add':
                rel = schema.getRelation(entity.name, relation.name);
                if (!rel) {
                  throw new Error('relation ' + entity.name + '=>' + relation.name + ' not found');
                }
                if (!rel.toMany) {
                  columnName = relation.name + '_id';
                  sqls.push(alterPrefix + ' ADD COLUMN ' + this._identifierColumn(columnName, false));
                  sqls.push(alterPrefix + ' ADD INDEX (`' + columnName + '`)');
                } else if (rel.toMany && ((_ref3 = rel.inverse) != null ? _ref3.toMany : void 0)) {
                  if (relation.type === 'add') {
                    sqls.push(this._manyToManyRelationDefinition(rel, entity));
                  }
                }
                break;
              case 'remove':
                rel = oldSchema.getRelation(entity.name, relation.name);
                if (!rel) {
                  throw new Error('relation ' + entity.name + '=>' + relation.name + ' not found');
                }
                if (!rel.toMany) {
                  columnName = relation.name + '_id';
                  sqls.push(alterPrefix + ' DROP COLUMN ' + this._identifierColumn(columnName, false));
                } else if (rel.toMany && ((_ref4 = rel.inverse) != null ? _ref4.toMany : void 0)) {
                  sqls.push('DROP TABLE IF EXISTS `' + this._relationTableName(rel, entity) + '`');
                }
                break;
            }
          }
        }
      }
      return newVersion;
    };

    MySQLSchemaGenerator.prototype._identifierColumn = function(name, notNull) {
      var sql;
      if (notNull == null) {
        notNull = true;
      }
      sql = '`' + name + '` ' + this._sqlTypeForColumnType(this.options.identifierType);
      if (notNull) {
        sql += ' NOT NULL';
      } else {
        sql += ' NULL DEFAULT NULL';
      }
      return sql;
    };

    MySQLSchemaGenerator.prototype._columnDefinitionForAttribute = function(column) {
      var defaultValue, definition, type;
      type = this._sqlTypeForColumnType(column.type, column);
      defaultValue = 'DEFAULT NULL';
      if (column["default"]) {
        defaultValue = "DEFAULT '" + column["default"] + "'";
      }
      definition = '`' + column.name + '` ' + type;
      if (column.notNull) {
        definition += ' NOT NULL';
      } else {
        definition += ' NULL';
      }
      definition += ' ' + defaultValue;
      if (column.unique) {
        definition += ', UNIQUE(`' + column.name + '`)';
      }
      return definition;
    };

    MySQLSchemaGenerator.prototype._sqlTypeForColumnType = function(columnType, options) {
      var length, type;
      if (options == null) {
        options = {};
      }
      type = null;
      if (options.length) {
        length = unitParser(options.length + 'B').to('B');
      }
      switch (columnType) {
        case 'bool':
        case 'boolean':
          return 'tinyint(1)';
        case 'string':
        case 'email':
        case 'url':
          return 'varchar(' + (length || 255) + ')';
        case 'text':
          if (length) {
            if (length < 256) {
              return 'tinytext';
            } else if (length < 65536) {
              return 'text';
            } else if (length < 16777216) {
              return 'mediumtext';
            } else if (length < 4294967296) {
              return 'longtext';
            }
          } else {
            return 'longtext';
          }
          break;
        case 'data':
          if (length) {
            if (length < 256) {
              return 'tinyblob';
            } else if (length < 65536) {
              return 'blob';
            } else if (length < 16777216) {
              return 'mediumblob';
            } else if (length < 4294967296) {
              return 'longblob';
            }
          } else {
            return 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          return 'int(' + (length || 11) + ')';
        case 'decimal':
          return 'decimal(' + (options.digits || 20) + ',' + (options.decimals || 5) + ')';
        case 'float':
          return 'float';
        case 'double':
          return 'double';
        case 'date':
          return 'datetime';
        case 'timestamp':
          return 'timestamp';
        default:
          throw new Error('unknown column type ' + columnType);
      }
    };

    return MySQLSchemaGenerator;

  })(SchemaGenerator);

  module.exports = MySQLSchemaGenerator;

}).call(this);
